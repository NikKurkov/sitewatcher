# sitewatcher/checks/malware_scan.py
from __future__ import annotations

import base64
import logging
from dataclasses import dataclass
from typing import Any, Dict, Optional

import httpx

from .base import BaseCheck, CheckOutcome, Status
from ..utils.rate_limit import MultiWindowRateLimiter


@dataclass(frozen=True)
class _VTConfig:
    """VirusTotal provider config (passive lookup only)."""
    api_key: Optional[str] = None
    submit_if_missing: bool = False  # reserved for future (2-phase), currently unused


def _b64url_no_padding(s: bytes) -> str:
    """Base64-url encode without '=' padding as required by VT URL ID."""
    out = base64.urlsafe_b64encode(s).decode("ascii")
    return out.rstrip("=")


class MalwareScanCheck(BaseCheck):
    """
    Malware/reputation check for the main page URL using external reputation services.

    MVP provider: VirusTotal passive URL report (no active submission).
    Mapping:
      - malicious > 0  -> CRIT
      - suspicious > 0 -> WARN
      - not found / only harmless/undetected -> OK
      - provider error / no API key -> UNKNOWN
    """
    name = "malware"  # short, friendly name

    def __init__(
        self,
        domain: str,
        *,
        client: httpx.AsyncClient,
        vt_cfg: Optional[_VTConfig] = None,
        timeout_s: float = 10.0,
        follow_redirects: bool = True,
        vt_limiter: Optional[MultiWindowRateLimiter] = None,
        vt_max_wait_s: float = 0.0,
        vt_limits_snapshot: Optional[dict] = None,
    ) -> None:
        """
        Args:
            domain: Domain to check (we'll normalize URL to https://<domain>/).
            client: shared httpx.AsyncClient from Dispatcher.
            vt_cfg: VirusTotal config (API key is required for VT).
            timeout_s: Per-provider timeout (seconds).
            follow_redirects: Whether to follow redirects when resolving canonical URL.
        """
        super().__init__(domain)
        self.client = client
        self.vt_cfg = vt_cfg or _VTConfig()
        self.timeout_s = float(timeout_s)
        self.follow_redirects = bool(follow_redirects)
        self._vt_limiter = vt_limiter
        self._vt_max_wait_s = float(vt_max_wait_s)
        self._vt_limits_snapshot = vt_limits_snapshot or {}

    async def run(self) -> CheckOutcome:
        # Build a canonical home URL. We intentionally do NOT strip query here.
        url = f"https://{self.domain.strip().lower().rstrip('.')}/"

        # --- Rate limiting for VirusTotal (Free tier) ---
        # If a shared limiter is configured, acquire a slot or return UNKNOWN if waiting is too long.
        if self._vt_limiter is not None and (self.vt_cfg.api_key or "").strip():
            ok, waited_or_delay = await self._vt_limiter.try_acquire(max_wait_s=self._vt_max_wait_s)
            if not ok:
                # Too many requests in the current window; do not hammer the API.
                msg = f"VT rate limited (wait {waited_or_delay:.2f}s)"
                metrics = {
                    "url": url,
                    "providers": {},
                    "vt_rate_limit": {
                        "acquired": False,
                        "needed_delay_s": float(waited_or_delay),
                        "limits": self._vt_limits_snapshot,
                        "max_wait_s": self._vt_max_wait_s,
                    },
                }
                return CheckOutcome(self.name, Status.UNKNOWN, msg, metrics)

        # 1) VirusTotal passive lookup
        vt_result: Optional[Dict[str, Any]] = None
        vt_status = "unavailable"
        try:
            vt_result = await self._vt_lookup(url)
            vt_status = "ok" if vt_result is not None else "not_found"
        except Exception as e:
            # Provider-specific errors should not break the whole check
            self.log.warning(
                "malware.vt.lookup_error",
                extra={"event": "malware.vt.lookup_error", "error": f"{e.__class__.__name__}: {e}"},
            )
            vt_status = "error"

        # Aggregate verdict
        verdict = Status.UNKNOWN
        reason_parts = []
        metrics: Dict[str, Any] = {"url": url, "providers": {}}
        if self._vt_limiter is not None:
            metrics["vt_rate_limit"] = {
                "acquired": True,
                "limits": self._vt_limits_snapshot,
                "max_wait_s": self._vt_max_wait_s,
            }

        if vt_result is not None:
            vt_stats = vt_result.get("stats") or {}
            malicious = int(vt_stats.get("malicious", 0) or 0)
            suspicious = int(vt_stats.get("suspicious", 0) or 0)
            harmless = int(vt_stats.get("harmless", 0) or 0)
            undetected = int(vt_stats.get("undetected", 0) or 0)

            # Decide status
            if malicious > 0:
                verdict = Status.CRIT
                reason_parts.append(f"VT: malicious={malicious}")
            elif suspicious > 0:
                verdict = Status.WARN
                reason_parts.append(f"VT: suspicious={suspicious}")
            else:
                # benign or unknown -> OK
                verdict = Status.OK
                reason_parts.append(f"VT: harmless={harmless}, undetected={undetected}")

            metrics["providers"]["virustotal"] = vt_result
        else:
            # If VT not configured or not found, keep UNKNOWN only if we have no other providers.
            # For MVP (single provider) we surface UNKNOWN; dispatcher cache/alert policy will handle it.
            verdict = Status.UNKNOWN
            reason_parts.append("VT: unavailable" if vt_status == "unavailable" else f"VT: {vt_status}")

        message = "; ".join(reason_parts)
        return CheckOutcome(self.name, verdict, message, metrics)

    # ---------------------- providers: VirusTotal ----------------------

    async def _vt_lookup(self, url: str) -> Optional[Dict[str, Any]]:
        """
        Query VirusTotal URL object (passive). Returns a compact dict with stats/links or None if not found.
        Docs: GET https://www.virustotal.com/api/v3/urls/{url_id}
        Where url_id = base64url(no padding) of the raw URL.
        """
        api_key = (self.vt_cfg.api_key or "").strip()
        if not api_key:
            # No API key configured â€” consider provider unavailable
            return None

        url_id = _b64url_no_padding(url.encode("utf-8"))
        endpoint = f"https://www.virustotal.com/api/v3/urls/{url_id}"
        headers = {"x-apikey": api_key}

        # Use shared client to benefit from connection pooling
        r = await self.client.get(endpoint, headers=headers, timeout=self.timeout_s)
        if r.status_code == 404:
            # Not found in VT passive DB
            return None
        r.raise_for_status()
        data = r.json()

        attrs = (data.get("data") or {}).get("attributes") or {}
        stats = attrs.get("last_analysis_stats") or {}
        links = (data.get("data") or {}).get("links") or {}
        rep_link = links.get("self") or f"https://www.virustotal.com/gui/url/{url_id}"

        # Normalize minimal payload for metrics
        return {
            "stats": {
                "harmless": int(stats.get("harmless", 0) or 0),
                "malicious": int(stats.get("malicious", 0) or 0),
                "suspicious": int(stats.get("suspicious", 0) or 0),
                "undetected": int(stats.get("undetected", 0) or 0),
                "timeout": int(stats.get("timeout", 0) or 0),
            },
            "report_url": rep_link,
            "analysis_date": attrs.get("last_analysis_date"),
            "categories": attrs.get("categories") or {},
        }
